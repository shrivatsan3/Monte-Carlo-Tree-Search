# Monte-Carlo-Tree-Search
Implements a version of Monte Carlo Tree Search in the programming language Julia and displays the resulting tree.

For the first iteration, we start at the node [19,19] and list all its actions. Since none of those actions has been taken, all of them have a UCB score of infinity. For the next four iterations, the algorithm takes those actions one by one, generates a child, lists all the actions of the child, performs rollouts from the child, and finally back propagates that value to every action of [19,19]. The rollout of Policy is to always take :right. Therefore, ([19,19], :up) state action pair has the highest Q value as going up from [19, 19] and taking a right reaches the terminal state. For the sixth iteration, ([19,19], :up) is selected because of its high UCB score, and the child [19, 20] is generated from it. Since the actions of [19,20] were already listed, all of which have an infinite UCB score, the algorithm spends sixth and seventh iteration trying two of those actions (which are :down and :right, simply because they come first when actions of the MDP are listed. Note that the algorithm wouldâ€™ve tried :up and :left for the subsequent eighth and nineth iteration). The actions for the resulting children are listed and rollouts are performed from these leaf nodes. ([19,20], :right) has the highest Q value since the rollouts reach the terminal state. In conclusion, all the actions corresponding to [19, 19] were taken once except :up, which was taken three times. The :up action was taken for the sixth and seventh iteration, Generating the state [19,20] both times. From [19,20], the actions :down and :right were tried once. N(s,a) and T(s,a) dictionaries reflect the course of action.
